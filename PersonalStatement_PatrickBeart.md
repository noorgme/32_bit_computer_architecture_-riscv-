# Patrick Beart
**Personal Statement**

This project took me from having some limited knowledge of assembly programming and awareness of the process by which a microarchitecture might execute machine code, to being aware of the precise architecture considerations involved in programming (most of) the RISCV-I instruction set. Particularly through debugging, I have gained an awareness of implementation details likely to be involved in microarchitecture for all instructions implemented by our CPU, and common patterns and pitfalls involved in RISCV programming generally.

## Contributions
- Top-level design ```riscv.sv```, responsibility for instruction memory ```instructionmemory.sv``` and design and implementation of pipelining.
- Bug fixes/validating (as did all other group members), easiest to see from commit history but e.g. fixing readmemh incorrectly loading memory by stripping spaces [commit 3cfba](https://github.com/EIE2-IAC-Labs/iac-riscv-cw-2/commit/3cfba6d6f32c2dc519f3f27cac0f2929b2259177), changing memory to prevent writing to x0 [commit 23fc9](https://github.com/EIE2-IAC-Labs/iac-riscv-cw-2/commit/23fc90d2a81f3ee4f425a02e4994245328fbab26)
- All build scripts  in ```./scripts``` (some of those in ```./scripts/assemble``` build on Prof. Cheung's scripts), as well as a script to automatically generate disassembly and format it so that it can be loaded into gtkWave and show instructions as assembly, and assert helper macro in ```/src/lib```.
- Test programs in ```/test/testcases``` and most in ```/test/samples``` which helped spot several bugs.
- Implementing final F1 program

## Notable work and some challenges
- I wrote the startlights.riscv.s program from a combination of what we all agreed we liked about the programs in `./test/samples/startlights`, but had to add the pseudorandom delay aspect. Given that we had not implemented multiplication, division or modulo it would have been tedious to implement a 'standard' PRNG algorithm, but since our seed was the number of clock cycles until the start button is pressed, which has a lot of information, I decided to simply truncate that number down to its last 3 bits and use that as the seed by shifting left and then right. This only gives 3 bits of entropy but this could be improved upon if a faster simulator were used as more and more bits of the counter would become hard to determine by the operator of the button.
- Pipelining was fairly simple, although I took the difficult decision of adding a clock signal to the control unit as there were internal signals which it would have been much more complicated to pull out to the top level: I added a `cdl` component (for clocked delay line) which takes an arbitrary length input and a clock and produces the output delayed by one cycle which made it fairly easy to produce delayed versions of each signal. I did have some problems towards the end with merging, which I resolved in an ugly way and suggest a development strategy with a single common branch to which only changes relevant to both pipelined and non-pipelined CPUs are pushed would have been better.

## Mistakes/would do differently
- It would have been significantly easier and simpler to implement pipelining if we had achieved full separation of concerns between modules from the start (i.e. ensuring each module takes only the inputs it needs and ideally avoid multiple stages of combinatoric logic), as this would have allowed pipelining to simply add clocked delays between each signal as shown on the diagram: I decided that we did not have enough time left to rewrite modules in a separated way so I instead decided that it was preferable to add clocked behaviour to the control unit so it could delay its internal signals for pipelining.

## Design Decisions
Consequential design decisions I made during the project:
- Early on, I decided to create a script (```build.sh```) to automate compiling and testing a module against its testbench: I also began writing testbenches which would raise errors if the design's behaviour was not as expected, and wrote an assert-with-error-message macro (in ```lib```) for the team to use, to make testing easier. This gave us much better visibility into which parts of our designs worked and provided another format to specify the design in (CPP vs SystemVerilog) as a sanity check.
- Building on this, I then wrote an additional ```assemble_test_riscv.sh``` script which uses a modified version of Prof. Cheung's Makefile and script to build and automatically run the provided assembly file (generating a mapping file to view disassembled instructions in gtkWave), and then wrote a script ```run_cpu_asm_tests.sh``` which iterates over every ```.s``` file in the ```./test/testcases``` directory, assembles and runs it, and then checks that the dumped registers are the same at program finish as they are in the corresponding testcase file: this allowed us to very easily check which features were and weren't implemented correctly, and implement regression testing where we could verify that a change had not broken any instructions.
